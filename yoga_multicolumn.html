<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>20250920 Yoga â€” å¤šæ¬„é¡¯ç¤º</title>
  <style>
    :root{--columns:1;--base-font:20px;--min-font:6px}
    html,body{height:100%;margin:0;background:#f7f7f8;font-family:-apple-system,BlinkMacSystemFont,'Noto Sans TC','Microsoft JhengHei',Roboto,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
    .page{box-sizing:border-box;width:100vw;height:100vh;padding:68px 40px 28px 40px;display:block;overflow:hidden}
    .sheet{height:100%;column-count:var(--columns);column-width:auto;column-gap:20px;column-fill:auto;background:linear-gradient(180deg,rgba(255,255,255,0.95),rgba(250,250,252,0.95));padding:18px;box-shadow:0 6px 20px rgba(0,0,0,0.06);border-radius:10px;overflow:auto;font-size:var(--base-font);line-height:1.45;column-rule:none}

    .sheet * {
      box-sizing: border-box;
    }
    h1{font-size:1.25em;margin:0 0 8px 0;break-inside:avoid}
    h2{font-size:0.98em;margin:6px 0 6px 0}
    ul,ol{margin:4px 0 12px 0;padding-left:1.1em;list-style-position:inside}
    li{margin:4px 0}
    h1,h2,li{break-inside:avoid-column}

    li::marker {
      display: inline-block;
      width: auto;
    }

    ol li, ul li {
      break-inside: avoid;
      page-break-inside: avoid;
    }

    /* Chrome ç€è¦½å™¨å¤šæ¬„ä½ˆå±€ ::marker ä¿®å¾© */
    @supports (column-count: 1) {
      ol {
        counter-reset: list-counter;
      }

      ol li {
        list-style: none;
        counter-increment: list-counter;
        position: relative;
        display: flex;
        align-items: flex-start;
      }

      ol li .li-number {
        content: counter(list-counter) ". ";
        font-weight: normal;
        margin-right: 0.5em;
        cursor: pointer;
        color: #007bff;
        text-decoration: underline;
        user-select: none;
        flex-shrink: 0;
        transition: color 0.2s ease;
      }

      ol li .li-number:hover {
        color: #0056b3;
        background-color: rgba(0, 123, 255, 0.1);
        border-radius: 3px;
        padding: 1px 3px;
      }

      ol li .li-content {
        flex: 1;
        cursor: pointer;
        user-select: none;
      }

      /* Hide the original ::before pseudo-element */
      ol li::before {
        display: none;
      }
    }

    @page{size:landscape}

    .toolbar{position:fixed;top:8px;left:8px;right:8px;background:rgba(255,255,255,0.95);border-radius:8px;padding:6px 8px;box-shadow:0 6px 18px rgba(0,0,0,0.08);z-index:100;display:flex;gap:8px;align-items:center;font-size:13px;flex-wrap:wrap}
    .toolbar label{display:flex;gap:6px;align-items:center;white-space:nowrap}
    .toolbar select,.toolbar button,.toolbar input{font-size:13px;padding:6px;border-radius:6px;border:1px solid #e6e6e9;background:#fff;cursor:pointer;min-width:0}
    .toolbar button[aria-pressed="true"]{background:#eaf3ff;border-color:#cfe6ff}

    .toolbar-narrow{display:none;position:fixed;top:8px;left:8px;right:8px;background:rgba(255,255,255,0.95);border-radius:8px;padding:4px 6px;box-shadow:0 6px 18px rgba(0,0,0,0.08);z-index:100;flex-wrap:wrap;gap:4px;align-items:center;justify-content:center;transition:transform 0.3s ease}
    .toolbar-narrow button{font-size:14px;padding:8px;border-radius:6px;border:1px solid #e6e6e9;background:#fff;cursor:pointer;min-width:36px;height:36px;display:flex;align-items:center;justify-content:center}
    .toolbar-narrow button[aria-pressed="true"]{background:#eaf3ff;border-color:#cfe6ff}
    .toolbar-narrow.hidden{transform:translateY(-100%)}
    .toolbar-narrow.minimized{display:flex!important;background:transparent;box-shadow:none;padding:0}
    .toolbar-narrow.minimized button:not(#toggleToolbarBtn):not(#memBtnNarrow):not(#resetMemBtnNarrow){display:none!important}
    .toolbar-narrow.minimized #toggleToolbarBtn{position:fixed;top:8px;right:8px;background:rgba(255,255,255,0.95);box-shadow:0 2px 8px rgba(0,0,0,0.15);z-index:101}
    .toolbar-narrow.minimized #memBtnNarrow{position:fixed;top:8px;right:60px;background:rgba(255,255,255,0.95);box-shadow:0 2px 8px rgba(0,0,0,0.15);z-index:101}
    .toolbar-narrow.minimized #resetMemBtnNarrow{position:fixed;top:8px;right:112px;background:rgba(255,255,255,0.95);box-shadow:0 2px 8px rgba(0,0,0,0.15);z-index:101}

    @media(max-width:768px){
      .toolbar{display:none}
      .toolbar-narrow{display:flex}
      .page{padding:60px 16px 16px 16px;transition:padding 0.3s ease}
      .page.toolbar-hidden{padding:16px 16px 16px 16px}
    }

    @media(max-width:480px){
      .page{padding:60px 8px 8px 8px}
    }

    @media (hover: none) and (pointer: coarse) {
      button {
        min-height: 44px;
        min-width: 44px;
        padding: 8px 12px;
        touch-action: manipulation;
      }

      .sheet {
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        touch-action: pan-y pinch-zoom;
      }

      .toolbar-narrow button {
        min-height: 48px;
        min-width: 48px;
        font-size: 16px;
      }

      body {
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
      }
    }

    .sheet:active {
      background-color: rgba(0,0,0,0.02);
    }

    /* Memory styles */
    .memorized {
      opacity: 0.6;
      text-decoration: line-through;
      background-color: rgba(0, 200, 0, 0.1);
    }

    .hidden-line {
      display: none !important;
    }

    .completed-last {
      color: red !important;
      font-weight: bold !important;
    }

    /* Music sync highlighting */
    .music-highlight {
      background-color: rgba(255, 193, 7, 0.3) !important;
      transition: background-color 0.5s ease;
    }

    .music-current {
      background-color: rgba(40, 167, 69, 0.4) !important;
      box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);
      transition: all 0.5s ease;
    }

    /* Auto play mode styling */
    .auto-play-current {
      background-color: rgba(0, 123, 255, 0.2) !important;
      border-left: 4px solid #007bff;
      padding-left: 8px;
      box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
      animation: autoPlayPulse 1s ease-in-out;
    }

    .auto-play-completed {
      background-color: rgba(40, 167, 69, 0.15) !important;
      border-left: 2px solid #28a745;
      padding-left: 10px;
      opacity: 0.8;
    }

    @keyframes autoPlayPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }

    /* Music Player styles */
    .music-player {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
      z-index: 200;
      min-width: 350px;
      max-width: 400px;
    }

    .music-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-weight: bold;
      font-size: 14px;
    }

    .music-header button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      font-size: 16px;
    }

    .music-header button:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    .music-content input {
      padding: 6px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 13px;
    }

    .music-content button {
      padding: 6px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      margin-left: 8px;
    }

    .music-content button:hover {
      background: #f0f0f0;
    }

    @media(max-width:768px) {
      .music-player {
        bottom: 10px;
        right: 10px;
        left: 10px;
        min-width: auto;
        max-width: none;
      }

      .music-content input {
        width: calc(100% - 80px) !important;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <nav class="toolbar" aria-label="æ–‡ä»¶æ§åˆ¶">
      <button id="memBtn" aria-pressed="false" title="åˆ‡æ›é»˜èƒŒæ¨¡å¼ï¼šæŒ‰ä¸€æ¬¡éš±è—å…¨éƒ¨ï¼Œå†æŒ‰ç©ºç™½æˆ– M é¡¯ç¤ºä¸‹ä¸€è¡Œ">ğŸ“– é»˜èƒŒæ¨¡å¼ (M / Space)</button>
      <button id="colBtn" title="åˆ‡æ›æ¬„æ•¸ (å¿«æ·éµ 1-6)">ğŸ“‘ 1æ¬„</button>

      <label>ğŸ”¤
        <input type="number" id="fontPreset" title="å­—å‹å¤§å° (å¿«æ·éµ +/-)" value="20" min="6" max="128" step="1" style="width: 60px;">
      </label>

      <button id="fontDecBtn" title="ç¸®å°å­—å‹ (å¿«æ·éµ -)">-</button>
      <button id="fontIncBtn" title="æ”¾å¤§å­—å‹ (å¿«æ·éµ +)">+</button>

      <button id="autoPlaySlowBtn" title="è‡ªå‹•æ’­æ”¾æ¸›é€Ÿ">ğŸŒ</button>
      <button id="autoPlayBtn" aria-pressed="false" title="è‡ªå‹•æ’­æ”¾é»˜èƒŒæ¨¡å¼ â€” å¿«æ·éµ A">â–¶ï¸ è‡ªå‹•æ’­æ”¾ 120â™© (A)</button>
      <button id="autoPlayFastBtn" title="è‡ªå‹•æ’­æ”¾åŠ é€Ÿ">ğŸ°</button>
      <button id="resetMemBtn" title="é‡ç½®é»˜èƒŒä¸¦é¡¯ç¤ºå…¨éƒ¨ â€” å¿«æ·éµ R">ğŸ”„ é‡ç½® (R)</button>
      <button id="copyBtn" title="è¤‡è£½å…¨éƒ¨å…§å®¹åˆ°å‰ªè²¼ç°¿ â€” å¿«æ·éµ C">ğŸ“‹ è¤‡è£½å…¨éƒ¨ (C)</button>
      <button id="musicBtn" title="é¡¯ç¤º/éš±è—éŸ³æ¨‚æ’­æ”¾å™¨">ğŸµ éŸ³æ¨‚</button>
      <button id="musicSyncBtn" title="é–‹å•Ÿ/é—œé–‰éŸ³æ¨‚åŒæ­¥é¡¯ç¤º">ğŸµ åŒæ­¥</button>
      <button id="helpBtn" title="é¡¯ç¤ºä½¿ç”¨èªªæ˜">â“ èªªæ˜</button>
    </nav>

    <!-- çª„è¢å¹•å°ˆç”¨å·¥å…·åˆ— -->
    <nav class="toolbar-narrow" aria-label="æ–‡ä»¶æ§åˆ¶">
      <button id="memBtnNarrow" aria-pressed="false" title="é»˜èƒŒæ¨¡å¼">ğŸ“–</button>
      <button id="colBtnNarrow" title="åˆ‡æ›æ¬„æ•¸">ğŸ“‘</button>
      <button id="fontDecBtnNarrow" title="ç¸®å°å­—å‹">A-</button>
      <button id="fontIncBtnNarrow" title="æ”¾å¤§å­—å‹">A+</button>
      <button id="autoPlaySlowBtnNarrow" title="æ¸›é€Ÿ">ğŸŒ</button>
      <button id="autoPlayBtnNarrow" aria-pressed="false" title="è‡ªå‹•æ’­æ”¾">120â™©</button>
      <button id="autoPlayFastBtnNarrow" title="åŠ é€Ÿ">ğŸ°</button>
      <button id="resetMemBtnNarrow" title="é‡ç½®">ğŸ”„</button>
      <button id="copyBtnNarrow" title="è¤‡è£½">ğŸ“‹</button>
      <button id="musicBtnNarrow" title="éŸ³æ¨‚">ğŸµ</button>
      <button id="musicSyncBtnNarrow" title="åŒæ­¥">ğŸ¶</button>
      <button id="helpBtnNarrow" title="èªªæ˜">â“</button>
      <button id="toggleToolbarBtn" title="åˆ‡æ›å·¥å…·åˆ—é¡¯ç¤º" >â˜°</button>
    </nav>

    <div id="sheet" class="sheet">
    </div>

    <!-- YouTube éŸ³æ¨‚æ’­æ”¾å™¨ -->
    <div id="musicPlayer" class="music-player" style="display: none;">
      <div class="music-header">
        <span>ğŸµ ç‘œä¼½éŸ³æ¨‚</span>
        <button id="closeMusicBtn" title="é—œé–‰éŸ³æ¨‚æ’­æ”¾å™¨">âœ•</button>
      </div>
      <div class="music-content">
        <select id="musicSelect" style="width: 100%; margin-bottom: 8px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="">é¸æ“‡é è¨­éŸ³æ¨‚...</option>
          <option value="https://www.youtube.com/watch?v=1ZYbU82GVz4">ç‘œä¼½éŸ³æ¨‚ - æ”¾é¬†å†¥æƒ³ (30åˆ†é˜)</option>
          <option value="https://www.youtube.com/watch?v=lFcSrYw-ARY">ç‘œä¼½éŸ³æ¨‚ - æ·±åº¦æ”¾é¬† (1å°æ™‚)</option>
          <option value="https://www.youtube.com/watch?v=_jCc40op6eM">ç‘œä¼½éŸ³æ¨‚ - èˆ’ç·©éŸ³æ¨‚ (45åˆ†é˜)</option>
          <option value="https://www.youtube.com/watch?v=uxbQATBAXf8">ç‘œä¼½éŸ³æ¨‚ - è‡ªç„¶éŸ³æ¨‚ (20åˆ†é˜)</option>
          <option value="custom">è‡ªè¨‚éŸ³æ¨‚é€£çµ...</option>
        </select>
        <input type="text" id="youtubeUrl" placeholder="è²¼ä¸Š YouTube éŸ³æ¨‚é€£çµ..." style="width: 100%; margin-bottom: 8px; display: none;">
        <div style="display: flex; gap: 4px;">
          <button id="loadMusicBtn" style="flex: 1;">è¼‰å…¥éŸ³æ¨‚</button>
          <button id="openYouTubeBtn" style="flex: 1;">åœ¨æ–°è¦–çª—é–‹å•Ÿ</button>
        </div>
        <div style="display: flex; gap: 4px; margin-top: 4px;">
          <button id="musicSyncBtnPlayer" style="flex: 1; background-color: #007bff; color: white;">ğŸµ åŒæ­¥</button>
          <select id="syncSpeedSelect" style="flex: 1; padding: 6px;">
            <option value="60">60 BPM</option>
            <option value="80">80 BPM</option>
            <option value="100">100 BPM</option>
            <option value="120" selected>120 BPM</option>
            <option value="140">140 BPM</option>
            <option value="160">160 BPM</option>
          </select>
        </div>
        <div id="youtubePlayer" style="margin-top: 8px;"></div>
        <div id="musicError" style="display: none; color: #e74c3c; font-size: 12px; margin-top: 8px;">
          ç„¡æ³•åµŒå…¥æ­¤éŸ³æ¨‚æ’­æ”¾å™¨ã€‚è«‹é»æ“Šä¸‹æ–¹é€£çµåœ¨æ–°è¦–çª—ä¸­æ’­æ”¾ï¼š<br>
          <a id="fallbackMusicLink" href="#" target="_blank" style="color: #007bff; text-decoration: underline; word-break: break-all; font-size: 11px;"></a>
        </div>
        <div id="musicUrlDisplay" style="display: none; margin-top: 8px; font-size: 12px; color: #666;">
          <strong>ç•¶å‰éŸ³æ¨‚ï¼š</strong><br>
          <a id="currentMusicLink" href="#" target="_blank" style="color: #007bff; text-decoration: underline; word-break: break-all; font-size: 11px;"></a>
          <div style="margin-top: 4px; font-style: italic; color: #888;">
            ğŸ’¡ æç¤ºï¼šé»é¸å‹•ä½œç·¨è™Ÿå¯é–‹å•Ÿè©²æ™‚é–“é»çš„éŸ³æ¨‚æ’­æ”¾ä¸¦å•Ÿå‹•è‡ªå‹•æ’­æ”¾æ¨¡å¼
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Markdown content for yoga practice
    const yogaContent = `# 20250920 Yoga

## A 00:00 8å€‹8æ‹(å‰å¥)
1. éŸ³æ¨‚é–‹å§‹5678
2. 22345678
3. å¤–æ‰‹åˆå5678
4. å…§æ‰‹åˆå5678
5. ä¸­é–“åˆæŒ5678
6. è½‰å‘345678
7. æ‰‹ä¸Š34å¾Œå½78
8. æ‰‹ä¸Š34åˆå78

## B 00:30 16å€‹8æ‹(äººè²)
1. åº§æ¤…345678
2. ç«™å§¿å‰å½5678
3. å¸æ°£é ­æŠ¬åæ°£å‰å½
4. å¾Œè·³ä¸‹çŠ¬5678
5. å¹³æ¿34è¶´ä¸‹78
6. è›‡å¼34ä¸‹çŠ¬78
7. å³è…³å¾ŒæŠ¬å‰è·¨78
8. ä¸Šè‹±é›„ä¸€5678
9. æ‰‹ä¸‹34ä¸‹çŠ¬78
10. å¹³æ¿34è¶´ä¸‹78
11. è›‡å¼34ä¸‹çŠ¬78
12. å·¦è…³å¾ŒæŠ¬å‰è·¨78
13. ä¸Šè‹±é›„ä¸€5678
14. æ‰‹ä¸‹34ä¸‹çŠ¬78
15. å‰è·³34å‰å½78
16. åº§æ¤…345678

## C 01:30 8å€‹8æ‹(é‡äººè²) ç«™å§¿
1. é›™æ‰‹åŠƒé–‹å±±å¼å›æ­£
2. é›™æ‰‹å‘ä¸Š5678
3. å·¦å´å½æ›²5678
4. å·¦å´å½å›5678
5. æ‰‹ä¸‹3456æ’è…°
6. å·¦è†å‰æŠ¬å·¦è†å¤–é–‹
7. åˆå345678
8. æ‰‹ä¸Š34æ‰‹ä¸‹è…³ä¸‹

## D 01:59 2å€‹8æ‹(ç„¡äººè²)è®Šæ›éšŠå½¢
1. è½‰135é¢å‘å‰é¢
2. è½‰24æ’é¢å‘å¾Œé¢

## E 02:05 16å€‹8æ‹(äººè²)
1. åº§æ¤…345678
2. ç«™å§¿å‰å½5678
3. å¸æ°£é ­æŠ¬åæ°£å‰å½
4. å¾Œè·³ä¸‹çŠ¬5678
5. å¹³æ¿34è¶´ä¸‹78
6. è›‡å¼34ä¸‹çŠ¬78
7. å³è…³å¾ŒæŠ¬å‰è·¨78
8. ä¸Šè‹±é›„ä¸€5678
9. æ‰‹ä¸‹34ä¸‹çŠ¬78
10. å¹³æ¿34è¶´ä¸‹78
11. è›‡å¼34ä¸‹çŠ¬78
12. å·¦è…³å¾ŒæŠ¬å‰è·¨78
13. ä¸Šè‹±é›„ä¸€5678
14. æ‰‹ä¸‹34ä¸‹çŠ¬78
15. å‰è·³34å‰å½78
16. åº§æ¤…345678

## F 03:05 8å€‹8æ‹(é‡äººè²) ç«™å§¿
1. é›™æ‰‹åŠƒé–‹å±±å¼å›æ­£
2. é›™æ‰‹å‘ä¸Š5678
3. å³å´å½æ›²5678
4. å³å´å½å›5678
5. æ‰‹ä¸‹3456æ’è…°
6. å³è†å‰æŠ¬å³è†å¤–é–‹
7. åˆå345678
8. æ‰‹ä¸Š34æ‰‹ä¸‹è…³ä¸‹

## G 03:35 10å€‹8æ‹(ç¯€å¥ç„¡äººè²)
1. é›™æ‰‹å‘ä¸Š5678
2. ç«™å§¿å‰å½5678
3. å³è…³å·¦è…³æº–å‚™å¬°å…’ / çƒé´‰é å‚™5678
4. å¬°å…’1æ¬¡5678      / çƒé´‰ä¸Šå»5678
5. å¬°å…’2æ¬¡5678      / çƒé´‰åœä½5678
6. ä¸‹çŠ¬1æ¬¡5678      / ä¸­é–“å¬°å…’5678
7. ä¸‹çŠ¬2æ¬¡5678      / ä¸­é–“å¬°å…’5678
8. ä¸‹çŠ¬34å¹³æ¿78
9. è¶´ä¸‹345678
10. è›‡å¼345678

## H 04:11 10å€‹8æ‹(å¾®éœ‡æ’¼ç„¡äººè²)
1. ä¸‹çŠ¬345678
2. å…§è·¨34è½‰å¤–78     # å…§è·¨æŒ‡è¿‘ä¸­é–“
3. å¸æ°£é ­æŠ¬åæ°£å‰å½
4. å‰æ‰‹æ’è…°å‰æ‰‹å±•é–‹
5. æ‰‹ä¸‹345678
6. å¾Œæ‰‹æ’è…°å¾Œæ‰‹å±•é–‹
7. æ‰‹ä¸‹345678
8. å¾Œè½‰34æ”¶è…³78
9. è¹²234æŠ±èºº78
10. é å‚™è¼ªå¼5678

## I 04:48 10å€‹8æ‹(å¾®éœ‡æ’¼ç„¡äººè²)
1. ä¸Š2345678  # 135æ’æ©‹å¼, 24æ’è¼ªå¼
2. æ’ä½34ä¸‹678
3. æŠ±è…³345678
4. å‰æ»¾ç«™èµ·5678
5. èµ°ä½345678
6. é›™äººä¸‹çŠ¬5678
7. å€’ç«‹æº–å‚™5678
8. ä¸Š2345678
9. æ’ä½345678
10. å³ä¸‹å·¦ä¸‹å°é½Šç«™èµ·  # åŒæ™‚åˆå

---
**çµæŸ**`;

    function parseMarkdownToHTML(markdown) {
      let html = '';
      const lines = markdown.split('\n');

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line.startsWith('# ')) {
          html += `<h1>${line.substring(2)}</h1>\n`;
        } else if (line.startsWith('## ')) {
          html += `<h2>${line.substring(3)}</h2>\n`;
        } else if (/^\d+\./.test(line)) {
          // Start or continue ordered list
          if (i === 0 || !(/^\d+\./.test(lines[i-1].trim()))) {
            html += '<ol>\n';
          }

          // Extract number and content
          const match = line.match(/^(\d+)\.\s*(.*)$/);
          if (match) {
            const number = match[1];
            const content = match[2];
            html += `<li><span class="li-number" data-number="${number}">${number}. </span><span class="li-content">${content}</span></li>\n`;
          } else {
            html += `<li>${line.replace(/^\d+\.\s*/, '')}</li>\n`;
          }

          // Check if next line is not a list item
          if (i === lines.length - 1 || !(/^\d+\./.test(lines[i+1].trim()))) {
            html += '</ol>\n';
          }
        } else if (line === '---') {
          // Skip horizontal rules in markdown
        } else if (line.startsWith('**') && line.endsWith('**')) {
          html += `<h2 id="endMarker" style="text-align: center; color: #888; margin-top: 30px;">â€” ${line.slice(2, -2)} â€”</h2>\n`;
        } else if (line === '') {
          // Skip empty lines
        }
      }

      return html;
    }

    function loadContentFromMarkdown() {
      const contentHTML = parseMarkdownToHTML(yogaContent);
      sheet.innerHTML = contentHTML;
    }

    function initializeAfterContentLoad() {
      // Check if content is loaded by verifying elements exist
      const elements = sheet.querySelectorAll('h1, h2, li');
      if (elements.length === 0) {
        // Content not ready yet, try again
        setTimeout(initializeAfterContentLoad, 50);
        return;
      }

      // Content is ready, proceed with initialization
      applyInitialSettings();
      initMemMode();
      updateAutoPlayButtons();
      setTimeout(checkToolbarWrap, 100);
    }

    const DEFAULT_FONT_SIZE = 20;

    const sheet = document.getElementById('sheet');
    const fontPreset = document.getElementById('fontPreset');
    const memBtn = document.getElementById('memBtn');
    const resetMemBtn = document.getElementById('resetMemBtn');
    const copyBtn = document.getElementById('copyBtn');
    const fontDecBtn = document.getElementById('fontDecBtn');
    const fontIncBtn = document.getElementById('fontIncBtn');
    const autoPlayBtn = document.getElementById('autoPlayBtn');
    const autoPlaySlowBtn = document.getElementById('autoPlaySlowBtn');
    const autoPlayFastBtn = document.getElementById('autoPlayFastBtn');

    const colBtn = document.getElementById('colBtn');

    const colBtnNarrow = document.getElementById('colBtnNarrow');
    const fontDecBtnNarrow = document.getElementById('fontDecBtnNarrow');
    const fontIncBtnNarrow = document.getElementById('fontIncBtnNarrow');
    const memBtnNarrow = document.getElementById('memBtnNarrow');
    const autoPlayBtnNarrow = document.getElementById('autoPlayBtnNarrow');
    const autoPlaySlowBtnNarrow = document.getElementById('autoPlaySlowBtnNarrow');
    const autoPlayFastBtnNarrow = document.getElementById('autoPlayFastBtnNarrow');
    const resetMemBtnNarrow = document.getElementById('resetMemBtnNarrow');
    const copyBtnNarrow = document.getElementById('copyBtnNarrow');
    const toggleToolbarBtn = document.getElementById('toggleToolbarBtn');
    const helpBtn = document.getElementById('helpBtn');
    const helpBtnNarrow = document.getElementById('helpBtnNarrow');
    const musicBtn = document.getElementById('musicBtn');
    const musicBtnNarrow = document.getElementById('musicBtnNarrow');
    const musicPlayer = document.getElementById('musicPlayer');
    const closeMusicBtn = document.getElementById('closeMusicBtn');
    const youtubeUrl = document.getElementById('youtubeUrl');
    const loadMusicBtn = document.getElementById('loadMusicBtn');
    const openYouTubeBtn = document.getElementById('openYouTubeBtn');
    const musicError = document.getElementById('musicError');
    const musicSelect = document.getElementById('musicSelect');
    const musicSyncBtn = document.getElementById('musicSyncBtn');
    const musicSyncBtnNarrow = document.getElementById('musicSyncBtnNarrow');
    const musicSyncBtnPlayer = document.getElementById('musicSyncBtnPlayer');
    const syncSpeedSelect = document.getElementById('syncSpeedSelect');
    const musicUrlDisplay = document.getElementById('musicUrlDisplay');
    const currentMusicLink = document.getElementById('currentMusicLink');
    const fallbackMusicLink = document.getElementById('fallbackMusicLink');

    let allLines = [];
    let memActive = false;
    let memIndex = 0;
    let autoPlayActive = false;
    let autoPlayTimer = null;
    let currentColumns = 1;
    let toolbarVisible = true;
    let autoPlaySpeed = 120; // BPM (beats per minute)
    let youtubePlayer = null;
    let musicPlayerVisible = false;
    let musicSyncActive = false;
    let musicSyncIndex = 0;
    let musicSyncTimer = null;
    let musicSyncSpeed = 120; // BPM for music sync

    // Default yoga music
    const defaultMusicUrl = 'https://www.youtube.com/watch?v=pICAha0nsb0';

    function getAutoPlayInterval() {
      // æ¯è¡Œ8æ‹ï¼Œæ‰€ä»¥é–“éš” = (60000ms / BPM) * 8
      return (60000 / autoPlaySpeed) * 8;
    }

    function setColumnCount(count) {
      currentColumns = count;
      sheet.style.columnCount = count;
      sheet.style.columnWidth = 'auto';
      sheet.style.columnRule = 'none';
      sheet.setAttribute('data-columns', count);

      const display = sheet.style.display;
      sheet.style.display = 'none';
      // eslint-disable-next-line no-unused-expressions
      sheet.offsetHeight;
      sheet.style.display = display;      updateColumnButtons();
    }

    function applyInitialSettings(){
      sheet.style.fontSize = fontPreset.value + 'px';

      const maxColumns = calculateMaxColumns();
      setColumnCount(maxColumns);
    }

    function updateColumnButtons(){
      colBtn.textContent = `ğŸ“‘ ${currentColumns}æ¬„`;
      colBtnNarrow.textContent = `ğŸ“‘${currentColumns}`;
    }

    function updateAutoPlayButtons(){
      const speedText = `${autoPlaySpeed}â™©`;
      autoPlayBtn.innerHTML = `â–¶ï¸ è‡ªå‹•æ’­æ”¾ ${speedText} (A)`;
      autoPlayBtnNarrow.innerHTML = `${speedText}`;
    }

    function changeAutoPlaySpeed(delta) {
      autoPlaySpeed = Math.max(60, Math.min(200, autoPlaySpeed + delta));
      updateAutoPlayButtons();

      // If auto play is active, restart with new speed
      if (autoPlayActive) {
        clearInterval(autoPlayTimer);
        autoPlayTimer = setInterval(() => {
          if (memActive && memIndex < allLines.length) {
            revealNextLine();
          } else {
            autoPlayActive = false;
            autoPlayBtn.setAttribute('aria-pressed', 'false');
            autoPlayBtnNarrow.setAttribute('aria-pressed', 'false');
            if (autoPlayTimer) {
              clearInterval(autoPlayTimer);
              autoPlayTimer = null;
            }
          }
        }, getAutoPlayInterval());
      }
    }

    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;
    let lastTouchEnd = 0;

    sheet.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }
    }, { passive: true });

    function handleDoubleTap(touchEndTime) {
      const isDoubleTap = touchEndTime - lastTouchEnd <= 300;
      lastTouchEnd = touchEndTime;
      return isDoubleTap;
    }

    function handleTap(deltaX, deltaY, deltaTime, e) {
      if (Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10 && deltaTime < 200) {
        // Check if the tap is on a clickable element on mobile
        const target = e.target;

        // Handle taps on li numbers (music play)
        if (target.classList.contains('li-number')) {
          e.preventDefault();
          target.click();
          return true;
        }

        // Handle taps on li content (memory mode)
        if (target.classList.contains('li-content')) {
          e.preventDefault();
          target.click();
          return true;
        }

        // Handle taps on li elements or h2 elements
        const isClickableElement = target.tagName === 'LI' || target.tagName === 'H2' || target.closest('li') || target.closest('h2');

        // On mobile devices with touch input, allow li and h2 clicks to pass through
        if (window.innerWidth <= 768 && isClickableElement) {
          // Trigger the click event manually to ensure consistent behavior
          e.preventDefault(); // Prevent duplicate events
          if (target.tagName === 'LI' || target.closest('li')) {
            const li = target.tagName === 'LI' ? target : target.closest('li');
            li.click();
          } else if (target.tagName === 'H2' || target.closest('h2')) {
            const h2 = target.tagName === 'H2' ? target : target.closest('h2');
            h2.click();
          }
          return true;
        }

        // For other cases, handle as memory mode toggle
        e.preventDefault();
        if (!memActive) {
          toggleMemMode();
        } else {
          revealNextLine();
        }
        return true;
      }
      return false;
    }

    function handleHorizontalSwipe(deltaX, e) {
      e.preventDefault();
      if (deltaX > 0) {
        toggleColumns();
      } else {
        const maxColumns = calculateMaxColumns();
        const nextColumns = currentColumns <= 1 ? maxColumns : currentColumns - 1;
        setColumnCount(nextColumns);
      }
    }

    function handleVerticalSwipe(deltaY, e) {
      e.preventDefault();
      if (deltaY < 0) {
        changeFont(2);
      } else {
        changeFont(-2);
      }
    }

    function handleSwipeGestures(deltaX, deltaY, deltaTime, e) {
      const minSwipeDistance = 50;
      const maxSwipeTime = 500;

      if (deltaTime >= maxSwipeTime) {
        return;
      }

      if (Math.abs(deltaX) > minSwipeDistance && Math.abs(deltaX) > Math.abs(deltaY)) {
        handleHorizontalSwipe(deltaX, e);
      }
      else if (Math.abs(deltaY) > minSwipeDistance && Math.abs(deltaY) > Math.abs(deltaX)) {
        handleVerticalSwipe(deltaY, e);
      }
    }

    sheet.addEventListener('touchend', (e) => {
      if (e.changedTouches.length !== 1) {
        return;
      }

      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      const touchEndTime = Date.now();

      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      const deltaTime = touchEndTime - touchStartTime;

      if (handleDoubleTap(touchEndTime)) {
        e.preventDefault();
        return;
      }

      if (handleTap(deltaX, deltaY, deltaTime, e)) {
        return;
      }

      handleSwipeGestures(deltaX, deltaY, deltaTime, e);
    }, { passive: false });

    function toggleColumns(){
      const maxColumns = calculateMaxColumns();
      const nextColumns = currentColumns >= maxColumns ? 1 : currentColumns + 1;
      setColumnCount(nextColumns);
    }

    function toggleToolbar(){
      const toolbarNarrow = document.querySelector('.toolbar-narrow');
      const page = document.querySelector('.page');

      if(toolbarVisible){
        // Hide all buttons except toggle button
        toolbarNarrow.classList.add('minimized');
        page.classList.add('toolbar-hidden');
        toggleToolbarBtn.textContent = 'â˜°';
        toolbarVisible = false;
      } else {
        // Show all buttons
        toolbarNarrow.classList.remove('minimized');
        page.classList.remove('toolbar-hidden');
        toggleToolbarBtn.textContent = 'â˜°';
        toolbarVisible = true;
      }
    }

    function calculateMaxColumns(){
      const viewportWidth = window.innerWidth - 80;
      const fontSize = parseInt(window.getComputedStyle(sheet).fontSize) || DEFAULT_FONT_SIZE;

      const testDiv = document.createElement('div');
      testDiv.style.cssText = `
        position: absolute;
        top: -9999px;
        font-family: ${window.getComputedStyle(sheet).fontFamily};
        font-size: ${fontSize}px;
        line-height: 1.45;
        white-space: nowrap;
        visibility: hidden;
      `;
      document.body.appendChild(testDiv);

      let maxLineWidth = 0;
      const lines = sheet.querySelectorAll('h1, h2, li');
      lines.forEach(line => {
        testDiv.textContent = line.textContent;
        maxLineWidth = Math.max(maxLineWidth, testDiv.offsetWidth);
      });

      document.body.removeChild(testDiv);

      const minColumnWidth = maxLineWidth + 40;
      const maxPossibleColumns = Math.floor(viewportWidth / minColumnWidth);
      return Math.max(1, Math.min(maxPossibleColumns, 6));
    }

    function responsiveColumnAdjust(){
      const maxColumns = calculateMaxColumns();
      setColumnCount(maxColumns);
    }

    function checkToolbarWrap(){
      if (window.innerWidth <= 768) {
        return;
      }

      const toolbar = document.querySelector('.toolbar');
      const toolbarNarrow = document.querySelector('.toolbar-narrow');
      const page = document.querySelector('.page');

      toolbar.style.display = 'flex';
      toolbarNarrow.style.display = 'none';

      setTimeout(() => {
        const buttons = toolbar.querySelectorAll('button, label');
        if (buttons.length < 2) return;

        const firstButton = buttons[0];
        const lastButton = buttons[buttons.length - 1];

        const firstRect = firstButton.getBoundingClientRect();
        const lastRect = lastButton.getBoundingClientRect();

        const isWrapped = Math.abs(firstRect.top - lastRect.top) > 10;

        if (isWrapped) {
          toolbar.style.display = 'none';
          toolbarNarrow.style.display = 'flex';
        } else {
          // Adjust page padding based on toolbar height
          const toolbarHeight = toolbar.offsetHeight;
          const newPaddingTop = toolbarHeight + 28; // 28px is base margin
          page.style.paddingTop = `${newPaddingTop}px`;
        }
      }, 10);
    }

    colBtn.addEventListener('click', toggleColumns);
    colBtnNarrow.addEventListener('click', toggleColumns);

    fontPreset.addEventListener('input', ()=>{
      const minFont = parseInt(fontPreset.min) || 6;
      const maxFont = parseInt(fontPreset.max) || 128;
      const fontSize = Math.max(minFont, Math.min(maxFont, parseInt(fontPreset.value) || DEFAULT_FONT_SIZE));
      fontPreset.value = fontSize;
      sheet.style.fontSize = fontSize + 'px';
      responsiveColumnAdjust();
      setTimeout(checkToolbarWrap, 100);
    });

    function changeFont(delta){
      const cur = parseInt(window.getComputedStyle(sheet).fontSize) || DEFAULT_FONT_SIZE;
      const minFont = parseInt(fontPreset.min) || 6;
      const maxFont = parseInt(fontPreset.max) || 128;
      const next = Math.max(minFont, Math.min(maxFont, cur + delta));
      sheet.style.fontSize = next + 'px';
      document.getElementById('fontPreset').value = next;
      responsiveColumnAdjust();
      setTimeout(checkToolbarWrap, 100);
    }

    function setColumns(n){
      const maxColumns = calculateMaxColumns();
      const num = Math.min(maxColumns, Math.max(1, Number(n)));
      setColumnCount(num);
    }

    function initMemMode(){
      const listItems = sheet.querySelectorAll('li');
      const h2Items = sheet.querySelectorAll('h2');

      // Make li elements clickable without checkboxes
      listItems.forEach((li, index) => {
        li.dataset.index = index;

        // Handle clicks on li number (open music)
        const liNumber = li.querySelector('.li-number');
        if (liNumber) {
          liNumber.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            openTimestampedUrl(index);
          });
        }

        // Handle clicks on li content (memory mode)
        const liContent = li.querySelector('.li-content');
        if (liContent) {
          liContent.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            handleLiClick(event, li);
          });
        }

        // Fallback: if clicked on li but not on specific parts
        li.addEventListener('click', (event) => {
          // Only trigger if the click wasn't handled by number or content
          if (!event.target.closest('.li-number') && !event.target.closest('.li-content')) {
            handleLiClick(event, li);
          }
        });
      });

      // Make h2 elements clickable for group control
      h2Items.forEach((h2, index) => {
        h2.style.cursor = 'pointer';
        h2.style.userSelect = 'none';
        h2.dataset.h2Index = index;
        h2.addEventListener('click', handleH2Click);
      });

      allLines = Array.from(sheet.querySelectorAll('li'));
      memActive = false;
      memIndex = 0;
      allLines.forEach(el => el.classList.remove('hidden-line', 'memorized'));
      memBtn.setAttribute('aria-pressed','false');
    }

    function handleLiClick(event, targetLi = null) {
      event.preventDefault();
      event.stopPropagation();

      const li = targetLi || event.currentTarget;

      // Toggle memorized state
      if (li.classList.contains('memorized')) {
        li.classList.remove('memorized');
      } else {
        li.classList.add('memorized');
      }

      // Clear completed state when manually changing memory state
      li.classList.remove('completed-last');

      // Update memory mode display if active
      if (memActive) {
        updateMemoryDisplay();
      }
    }

    function handleH2Click(event) {
      event.preventDefault();
      event.stopPropagation();

      const h2 = event.currentTarget;

      // Find all li elements that belong to this h2 section
      let currentElement = h2.nextElementSibling;
      const sectionLiElements = [];

      while (currentElement && currentElement.tagName !== 'H2') {
        if (currentElement.tagName === 'OL' || currentElement.tagName === 'UL') {
          // If it's a list, get all li elements inside it
          const lis = currentElement.querySelectorAll('li');
          sectionLiElements.push(...lis);
        } else if (currentElement.tagName === 'LI') {
          sectionLiElements.push(currentElement);
        }
        currentElement = currentElement.nextElementSibling;
      }

      // Check current state of all li elements in this section
      const memorizedCount = sectionLiElements.filter(li => li.classList.contains('memorized')).length;
      const totalCount = sectionLiElements.length;

      let shouldMemorize;
      if (memorizedCount === 0) {
        // All unmemorized -> memorize all
        shouldMemorize = true;
      } else if (memorizedCount === totalCount) {
        // All memorized -> unmemorize all
        shouldMemorize = false;
      } else {
        // Partially memorized -> unmemorize all
        shouldMemorize = false;
      }

      // Apply the new state to all li elements in this section
      sectionLiElements.forEach(li => {
        if (shouldMemorize) {
          li.classList.add('memorized');
        } else {
          li.classList.remove('memorized');
        }
        // Clear completed state when manually changing memory state
        li.classList.remove('completed-last');
      });

      // Update memory mode display if active
      if (memActive) {
        updateMemoryDisplay();
      }
    }

    function updateMemoryDisplay() {
      allLines.forEach((li, index) => {
        if (li.classList.contains('memorized')) {
          // Keep memorized items visible
          li.classList.remove('hidden-line');
        } else if (memActive) {
          // In memory mode, only hide lines that haven't been revealed yet
          if (index >= memIndex) {
            li.classList.add('hidden-line');
          }
          // Don't hide lines that have already been revealed (index < memIndex)
        }
      });
    }

    function hideUnmemorizedLines(){
      allLines.forEach(li => {
        if (!li.classList.contains('memorized')) {
          li.classList.add('hidden-line');
        }
      });
    }

    function revealNextLine(){
      // Find next unmemorized line
      while(memIndex < allLines.length) {
        const li = allLines[memIndex];

        if (!li.classList.contains('memorized')) {
          // This is an unmemorized line, reveal it
          li.classList.remove('hidden-line');

          // è‡ªå‹•æ»¾å‹•åˆ°æœ€å¾Œé¡¯ç¤ºçš„è¡Œ
          li.scrollIntoView({
            behavior: 'smooth',
            block: 'end'
          });

          memIndex++;
          return;
        }

        // Skip memorized lines
        memIndex++;
      }

      // No more unmemorized lines - mark the end marker as completed
      const endMarker = document.getElementById('endMarker');
      if (endMarker) {
        endMarker.classList.add('completed-last');
      }

      memActive = false;
      memBtn.setAttribute('aria-pressed','false');
      memBtnNarrow.setAttribute('aria-pressed','false');
      memIndex = 0;
    }

    function toggleMemMode(){
      if(!memActive){
        hideUnmemorizedLines();
        memActive = true;
        memIndex = 0;
        memBtn.setAttribute('aria-pressed','true');
        memBtnNarrow.setAttribute('aria-pressed','true');
      } else {
        revealNextLine();
      }
    }

    function resetMem(){
      allLines.forEach(el => {
        el.classList.remove('hidden-line', 'memorized', 'completed-last', 'auto-play-current', 'auto-play-completed', 'music-highlight', 'music-current');
      });

      // Also clear the end marker
      const endMarker = document.getElementById('endMarker');
      if (endMarker) {
        endMarker.classList.remove('completed-last');
      }

      memActive = false;
      memIndex = 0;
      autoPlayActive = false;
      if(autoPlayTimer) {
        clearInterval(autoPlayTimer);
        autoPlayTimer = null;
      }

      // Stop music sync as well
      stopMusicSync();

      memBtn.setAttribute('aria-pressed','false');
      autoPlayBtn.setAttribute('aria-pressed','false');
      memBtnNarrow.setAttribute('aria-pressed','false');
      autoPlayBtnNarrow.setAttribute('aria-pressed','false');

      resetFontSize();
    }

    function resetFontSize() {
      fontPreset.value = DEFAULT_FONT_SIZE;
      sheet.style.fontSize = DEFAULT_FONT_SIZE + 'px';

      const maxColumns = calculateMaxColumns();
      setColumnCount(maxColumns);
    }

    function showHelp() {
      const helpContent = `
ğŸ“– ç‘œä¼½ç·´ç¿’é é¢ä½¿ç”¨èªªæ˜

âš¡ å¿«é€Ÿæ“ä½œ
ğŸ’» é›»è…¦ï¼šSpaceéµ=è¨˜æ†¶æ¨¡å¼ | Réµ=é‡ç½® | Méµ=è¨˜æ†¶åˆ‡æ›
ğŸ“± è§¸æ§ï¼šå–®æ“Š=è¨˜æ†¶æ¨¡å¼ | å·¦å³æ»‘=èª¿æ¬„æ•¸ | ä¸Šä¸‹æ»‘=èª¿å­—å‹

ğŸµ éŸ³æ¨‚åŒæ­¥åŠŸèƒ½
â€¢ é»é¸å‹•ä½œç·¨è™Ÿï¼šé–‹å•Ÿè©²å‹•ä½œæ™‚é–“é»çš„éŸ³æ¨‚æ’­æ”¾ä¸¦å•Ÿå‹•è‡ªå‹•æ’­æ”¾æ¨¡å¼
â€¢ é»é¸å‹•ä½œå…§å®¹ï¼šåˆ‡æ›è¨˜æ†¶æ¨¡å¼ç‹€æ…‹
â€¢ è‡ªå‹•æ’­æ”¾æ¨¡å¼ï¼šå¾æŒ‡å®šå‹•ä½œé–‹å§‹ï¼ŒæŒ‰ç¯€æ‹è‡ªå‹•é«˜äº®é¡¯ç¤ºå¾ŒçºŒå‹•ä½œ
â€¢ åŒæ­¥æ’­æ”¾ï¼šé–‹å•ŸåŒæ­¥æ¨¡å¼ï¼ŒéŸ³æ¨‚æ’­æ”¾æ™‚æœƒé«˜äº®é¡¯ç¤ºå°æ‡‰å‹•ä½œ
â€¢ BPMèª¿æ•´ï¼šå¯èª¿æ•´ 60-160 BPM çš„åŒæ­¥é€Ÿåº¦
â€¢ åµŒå…¥å¤±æ•—ï¼šç•¶ç„¡æ³•åµŒå…¥YouTubeæ’­æ”¾å™¨æ™‚ï¼Œæœƒé¡¯ç¤ºå¯é»æ“Šçš„é€£çµ

 Memoryæ¨¡å¼é¡¯ç¤ºé‚è¼¯
â€¢ é †åºé¡¯ç¤ºï¼šå¤šæ¬„æ¨¡å¼ä¸‹å…ˆé¡¯ç¤ºå®Œç¬¬ä¸€æ¬„ï¼Œå†é¡¯ç¤ºç¬¬äºŒæ¬„
â€¢ è¡Œç´šæ§åˆ¶ï¼šæ¯æ¬¡æŒ‰ç©ºç™½éµæˆ–Méµé¡¯ç¤ºä¸‹ä¸€è¡Œå…§å®¹
â€¢ è‡ªå‹•æ’­æ”¾ï¼šå¯è¨­å®šæ¯4ç§’è‡ªå‹•é¡¯ç¤ºä¸‹ä¸€è¡Œ

ğŸ“± è§¸æ§æ‰‹å‹¢æ“ä½œ
ğŸ‘† å–®æ“Šå‹•ä½œç·¨è™Ÿï¼šé–‹å•Ÿè©²æ™‚é–“é»çš„éŸ³æ¨‚æ’­æ”¾ä¸¦å•Ÿå‹•è‡ªå‹•æ’­æ”¾æ¨¡å¼
ğŸ‘† å–®æ“Šå‹•ä½œå…§å®¹ï¼šåˆ‡æ›è¨˜æ†¶æ¨¡å¼ç‹€æ…‹
ğŸ‘ˆğŸ‘‰ å·¦å³æ»‘å‹•ï¼šèª¿æ•´æ¬„æ•¸ (â†’å³æ»‘å¢åŠ ï¼Œâ†å·¦æ»‘æ¸›å°‘)
ğŸ‘†ğŸ‘‡ ä¸Šä¸‹æ»‘å‹•ï¼šèª¿æ•´å­—å‹ (â†‘ä¸Šæ»‘æ”¾å¤§ï¼Œâ†“ä¸‹æ»‘ç¸®å°)

âŒ¨ï¸ éµç›¤å¿«æ·éµ
Spaceï¼šè¨˜æ†¶æ¨¡å¼åˆ‡æ›/é¡¯ç¤ºä¸‹ä¸€è¡Œ
Rï¼šé‡ç½® | Mï¼šè¨˜æ†¶æ¨¡å¼åˆ‡æ› | Aï¼šè‡ªå‹•æ’­æ”¾åˆ‡æ›
Cï¼šè¤‡è£½å…¨éƒ¨å…§å®¹ | +/-ï¼šæ”¾å¤§/ç¸®å°å­—å‹ | 1-6ï¼šç›´æ¥è¨­å®šæ¬„æ•¸
      `;

      alert(helpContent);
    }

    function toggleMusicPlayer() {
      if (musicPlayerVisible) {
        musicPlayer.style.display = 'none';
        musicPlayerVisible = false;
      } else {
        musicPlayer.style.display = 'block';
        musicPlayerVisible = true;
      }
    }

    function extractVideoId(url) {
      const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
      const match = url.match(regExp);
      return (match && match[2].length === 11) ? match[2] : null;
    }

    function loadYouTubeAPI() {
      if (window.YT) {
        return Promise.resolve();
      }

      return new Promise((resolve) => {
        const tag = document.createElement('script');
        tag.src = 'https://www.youtube.com/iframe_api';
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        window.onYouTubeIframeAPIReady = resolve;
      });
    }

    function createYouTubePlayer(videoId) {
      const currentUrl = youtubeUrl.value.trim() || defaultMusicUrl;
      const musicUrlDisplay = document.getElementById('musicUrlDisplay');
      const currentMusicLink = document.getElementById('currentMusicLink');
      const musicError = document.getElementById('musicError');
      const fallbackMusicLink = document.getElementById('fallbackMusicLink');

      // Always show current music URL
      currentMusicLink.href = currentUrl;
      currentMusicLink.textContent = currentUrl;
      musicUrlDisplay.style.display = 'block';

      // Hide error initially
      musicError.style.display = 'none';

      loadYouTubeAPI().then(() => {
        if (youtubePlayer) {
          youtubePlayer.destroy();
        }

        youtubePlayer = new YT.Player('youtubePlayer', {
          height: '200',
          width: '100%',
          videoId: videoId,
          playerVars: {
            autoplay: 0,
            controls: 1,
            rel: 0,
            showinfo: 0,
            modestbranding: 1,
            origin: window.location.origin
          },
          events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange,
            'onError': function(event) {
              console.warn('YouTube Player Error:', event.data);
              showEmbedError(currentUrl);
            }
          }
        });

        // Set a timeout to detect if player fails to load
        setTimeout(() => {
          if (!youtubePlayer || !youtubePlayer.getPlayerState) {
            showEmbedError(currentUrl);
          }
        }, 5000);

      }).catch(error => {
        console.error('YouTube API Error:', error);
        showEmbedError(currentUrl);
      });
    }

    function showEmbedError(currentUrl) {
      const musicError = document.getElementById('musicError');
      const fallbackMusicLink = document.getElementById('fallbackMusicLink');

      fallbackMusicLink.href = currentUrl;
      fallbackMusicLink.textContent = currentUrl;
      musicError.style.display = 'block';
    }

    function onPlayerReady(event) {
      console.log('YouTube player ready');
    }

    function onPlayerStateChange(event) {
      if (event.data === YT.PlayerState.PLAYING) {
        if (musicSyncActive) {
          startMusicSync();
        }
      } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
        if (musicSyncActive) {
          stopMusicSync();
        }
      }
    }

    function startMusicSync() {
      stopMusicSync(); // Clear any existing timer
      musicSyncIndex = 0;

      // Clear previous highlights
      document.querySelectorAll('.music-highlight, .music-current').forEach(el => {
        el.classList.remove('music-highlight', 'music-current');
      });

      // Calculate timing based on BPM (8 beats per line)
      const beatsPerLine = 8;
      const millisecondsPerBeat = 60000 / musicSyncSpeed;
      const millisecondsPerLine = millisecondsPerBeat * beatsPerLine;

      musicSyncTimer = setInterval(() => {
        const allItems = document.querySelectorAll('#sheet li, #sheet h2');

        if (musicSyncIndex < allItems.length) {
          // Remove previous current highlight
          document.querySelectorAll('.music-current').forEach(el => {
            el.classList.remove('music-current');
            el.classList.add('music-highlight');
          });

          const currentItem = allItems[musicSyncIndex];

          if (memActive) {
            // In memory mode, reveal the line
            currentItem.classList.add('memorized');
          }

          // Add current highlight
          currentItem.classList.add('music-current');

          musicSyncIndex++;
        } else {
          // Reached the end
          stopMusicSync();
        }
      }, millisecondsPerLine);
    }

    function stopMusicSync() {
      if (musicSyncTimer) {
        clearInterval(musicSyncTimer);
        musicSyncTimer = null;
      }
    }

    function toggleMusicSync() {
      musicSyncActive = !musicSyncActive;
      const syncBtn = document.getElementById('musicSyncBtn');
      const syncBtnNarrow = document.getElementById('musicSyncBtnNarrow');
      const syncBtnPlayer = document.getElementById('musicSyncBtnPlayer');

      if (musicSyncActive) {
        syncBtn.textContent = 'ğŸµ åŒæ­¥ä¸­';
        syncBtn.style.backgroundColor = '#28a745';
        syncBtnNarrow.textContent = 'ğŸ¶';
        syncBtnNarrow.style.backgroundColor = '#28a745';
        syncBtnPlayer.textContent = 'ğŸµ åŒæ­¥ä¸­';
        syncBtnPlayer.style.backgroundColor = '#28a745';

        // If music is playing, start sync immediately
        if (youtubePlayer && youtubePlayer.getPlayerState && youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING) {
          startMusicSync();
        }
      } else {
        syncBtn.textContent = 'ğŸµ åŒæ­¥';
        syncBtn.style.backgroundColor = '#007bff';
        syncBtnNarrow.textContent = 'ğŸ¶';
        syncBtnNarrow.style.backgroundColor = '#007bff';
        syncBtnPlayer.textContent = 'ğŸµ åŒæ­¥';
        syncBtnPlayer.style.backgroundColor = '#007bff';
        stopMusicSync();

        // Clear all highlights
        document.querySelectorAll('.music-highlight, .music-current').forEach(el => {
          el.classList.remove('music-highlight', 'music-current');
        });
      }
    }

    // Calculate timestamp for a specific line index based on BPM
    function calculateLineTimestamp(lineIndex) {
      const beatsPerLine = 8;
      const millisecondsPerBeat = 60000 / musicSyncSpeed;
      const millisecondsPerLine = millisecondsPerBeat * beatsPerLine;
      return (lineIndex * millisecondsPerLine) / 1000; // Return in seconds
    }

    // Generate YouTube URL with timestamp
    function generateTimestampedUrl(lineIndex) {
      const timestamp = Math.floor(calculateLineTimestamp(lineIndex));
      const currentUrl = youtubeUrl.value.trim() || defaultMusicUrl;

      // Remove existing timestamp parameter if present
      let baseUrl = currentUrl.replace(/[&?]t=\d+/, '');

      // Add timestamp parameter
      const separator = baseUrl.includes('?') ? '&' : '?';
      return `${baseUrl}${separator}t=${timestamp}`;
    }

    // Start automatic play mode from a specific line
    function startAutoPlayFromLine(startLineIndex) {
      // Clear any existing auto play or music sync
      if (autoPlayTimer) {
        clearInterval(autoPlayTimer);
        autoPlayTimer = null;
      }
      stopMusicSync();

      // Clear previous styling
      document.querySelectorAll('.auto-play-current, .auto-play-completed, .music-highlight, .music-current').forEach(el => {
        el.classList.remove('auto-play-current', 'auto-play-completed', 'music-highlight', 'music-current');
      });

      // Enable memory mode if not already active
      if (!memActive) {
        toggleMemMode();
      }

      // Set up auto play from the specified line
      const allItems = document.querySelectorAll('#sheet li');
      let currentIndex = startLineIndex;

      // Mark previous lines as completed
      for (let i = 0; i < startLineIndex && i < allItems.length; i++) {
        allItems[i].classList.add('auto-play-completed', 'memorized');
      }

      // Start the auto play sequence
      function playNextLine() {
        if (currentIndex >= allItems.length) {
          // Reached the end
          autoPlayActive = false;
          autoPlayBtn.setAttribute('aria-pressed', 'false');
          autoPlayBtnNarrow.setAttribute('aria-pressed', 'false');
          if (autoPlayTimer) {
            clearInterval(autoPlayTimer);
            autoPlayTimer = null;
          }
          return;
        }

        // Remove previous current highlighting
        document.querySelectorAll('.auto-play-current').forEach(el => {
          el.classList.remove('auto-play-current');
          el.classList.add('auto-play-completed');
        });

        // Highlight current line
        const currentLine = allItems[currentIndex];
        currentLine.classList.add('auto-play-current', 'memorized');

        // Scroll to current line if needed
        currentLine.scrollIntoView({
          behavior: 'smooth',
          block: 'center',
          inline: 'nearest'
        });

        currentIndex++;
      }

      // Start immediately with the first line
      playNextLine();

      // Set up interval for subsequent lines
      autoPlayActive = true;
      autoPlayBtn.setAttribute('aria-pressed', 'true');
      autoPlayBtnNarrow.setAttribute('aria-pressed', 'true');

      autoPlayTimer = setInterval(playNextLine, getAutoPlayInterval());
    }

    // Open timestamped URL in new window and start play mode
    function openTimestampedUrl(lineIndex) {
      const timestampedUrl = generateTimestampedUrl(lineIndex);
      const timestamp = Math.floor(calculateLineTimestamp(lineIndex));

      // Open in new window
      window.open(timestampedUrl, '_blank');

      // Start automatic play mode from this line
      startAutoPlayFromLine(lineIndex);

      // Show notification
      showCopyNotification(`å·²é–‹å•Ÿæ™‚é–“é» ${timestamp}s çš„éŸ³æ¨‚æ’­æ”¾ï¼Œä¸¦å•Ÿå‹•è‡ªå‹•æ’­æ”¾æ¨¡å¼`);
    }

    // Copy timestamped URL to clipboard (kept as alternative)
    function copyTimestampedUrl(lineIndex) {
      const timestampedUrl = generateTimestampedUrl(lineIndex);

      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(timestampedUrl).then(() => {
          // Show temporary notification
          showCopyNotification(`å·²è¤‡è£½æ™‚é–“é» ${Math.floor(calculateLineTimestamp(lineIndex))}s çš„éŸ³æ¨‚é€£çµ`);
        }).catch(err => {
          console.error('Failed to copy to clipboard:', err);
          fallbackCopyToClipboard(timestampedUrl);
        });
      } else {
        fallbackCopyToClipboard(timestampedUrl);
      }
    }

    // Fallback copy method
    function fallbackCopyToClipboard(text) {
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();

      try {
        document.execCommand('copy');
        showCopyNotification('å·²è¤‡è£½éŸ³æ¨‚é€£çµåˆ°å‰ªè²¼ç°¿');
      } catch (err) {
        console.error('Failed to copy:', err);
        alert('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•è¤‡è£½ï¼š\n' + text);
      }

      document.body.removeChild(textArea);
    }

    // Show copy notification
    function showCopyNotification(message) {
      // Remove existing notification if any
      const existingNotification = document.querySelector('.copy-notification');
      if (existingNotification) {
        existingNotification.remove();
      }

      // Create notification element
      const notification = document.createElement('div');
      notification.className = 'copy-notification';
      notification.textContent = message;
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transition: all 0.3s ease;
      `;

      document.body.appendChild(notification);

      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.opacity = '0';
          notification.style.transform = 'translateY(-20px)';
          setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, 300);
        }
      }, 3000);
    }

    function loadMusic() {
      const url = youtubeUrl.value.trim();
      if (!url) {
        alert('è«‹è¼¸å…¥ YouTube é€£çµ');
        return;
      }

      const videoId = extractVideoId(url);
      if (!videoId) {
        alert('ç„¡æ•ˆçš„ YouTube é€£çµæ ¼å¼');
        return;
      }

      // Hide error message and try to load player
      musicError.style.display = 'none';
      createYouTubePlayer(videoId);

      // Show error message after a delay if there are issues
      setTimeout(() => {
        musicError.style.display = 'block';
      }, 3000);
    }

    function openYouTube() {
      const url = youtubeUrl.value.trim();
      if (!url) {
        alert('è«‹è¼¸å…¥ YouTube é€£çµ');
        return;
      }

      window.open(url, '_blank');
    }

    function toggleAutoPlay(){
      if(!autoPlayActive){
        // Clear any existing auto play styling
        document.querySelectorAll('.auto-play-current, .auto-play-completed').forEach(el => {
          el.classList.remove('auto-play-current', 'auto-play-completed');
        });

        if(!memActive){
          toggleMemMode();
        }
        autoPlayActive = true;
        autoPlayBtn.setAttribute('aria-pressed','true');
        autoPlayBtnNarrow.setAttribute('aria-pressed','true');

        // Immediately reveal the next line without delay
        if(memActive && memIndex < allLines.length){
          revealNextLine();
        }

        autoPlayTimer = setInterval(()=>{
          if(memActive && memIndex < allLines.length){
            revealNextLine();
          } else {
            autoPlayActive = false;
            autoPlayBtn.setAttribute('aria-pressed','false');
            autoPlayBtnNarrow.setAttribute('aria-pressed','false');
            if(autoPlayTimer) {
              clearInterval(autoPlayTimer);
              autoPlayTimer = null;
            }
          }
        }, getAutoPlayInterval());
      } else {
        autoPlayActive = false;
        autoPlayBtn.setAttribute('aria-pressed','false');
        autoPlayBtnNarrow.setAttribute('aria-pressed','false');
        if(autoPlayTimer) {
          clearInterval(autoPlayTimer);
          autoPlayTimer = null;
        }

        // Clear auto play styling when stopping
        document.querySelectorAll('.auto-play-current, .auto-play-completed').forEach(el => {
          el.classList.remove('auto-play-current', 'auto-play-completed');
        });
      }
    }

    function copyAll(){
      const visibleElements = Array.from(sheet.querySelectorAll('h1, h2, ol')).filter(el =>
        !el.classList.contains('hidden-line')
      );

      const text = visibleElements.map(node => {
        if (node.tagName === 'OL') {
          const visibleItems = Array.from(node.querySelectorAll('li')).filter(li =>
            !li.classList.contains('hidden-line')
          ).map((li, index) => {
            return `${index + 1}. ${li.textContent}`;
          }).join('\n');
          return visibleItems;
        } else {
          return node.innerText;
        }
      }).join('\n\n');

      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(text).then(()=>{
          const prev = copyBtn.innerText;
          copyBtn.innerText = 'å·²è¤‡è£½';
          setTimeout(()=>copyBtn.innerText = prev,900);
        }).catch(()=>{
          alert('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸å–å¾Œè¤‡è£½');
        });
      } else {
        alert('æ­¤ç€è¦½å™¨ä¸æ”¯æ´å‰ªè²¼ç°¿ APIï¼Œè«‹æ‰‹å‹•è¤‡è£½');
      }
    }

    document.addEventListener('keydown', (e) => {
      const activeTag = document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || document.activeElement.isContentEditable);
      if(activeTag) return;

      if(e.code === 'Space'){
        e.preventDefault();
        if(!memActive){ toggleMemMode(); } else { revealNextLine(); }
        return;
      }

      switch(e.key){
        case 'm': case 'M': e.preventDefault(); toggleMemMode(); break;
        case 'a': case 'A': e.preventDefault(); toggleAutoPlay(); break;
        case 'r': case 'R': e.preventDefault(); resetMem(); break;
        case 'c': case 'C': e.preventDefault(); copyAll(); break;
        case '+': case '=': e.preventDefault(); changeFont(1); break;
        case '-': e.preventDefault(); changeFont(-1); break;
        case '1': case '2': case '3': case '4': case '5': case '6': e.preventDefault(); setColumns(Number(e.key)); break;
      }
    });

    memBtn.addEventListener('click', (e)=>{ toggleMemMode(); });
    autoPlayBtn.addEventListener('click', (e)=>{ toggleAutoPlay(); });
    resetMemBtn.addEventListener('click', resetMem);
    copyBtn.addEventListener('click', copyAll);
    fontDecBtn.addEventListener('click', ()=>{ changeFont(-1); });
    fontIncBtn.addEventListener('click', ()=>{ changeFont(1); });
    toggleToolbarBtn.addEventListener('click', toggleToolbar);
    helpBtn.addEventListener('click', showHelp);
    musicBtn.addEventListener('click', toggleMusicPlayer);
    closeMusicBtn.addEventListener('click', toggleMusicPlayer);
    loadMusicBtn.addEventListener('click', loadMusic);
    openYouTubeBtn.addEventListener('click', openYouTube);

    // Allow Enter key to load music
    youtubeUrl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        loadMusic();
      }
    });

    autoPlaySlowBtn.addEventListener('click', () => changeAutoPlaySpeed(-10));
    autoPlayFastBtn.addEventListener('click', () => changeAutoPlaySpeed(10));
    autoPlaySlowBtnNarrow.addEventListener('click', () => changeAutoPlaySpeed(-10));
    autoPlayFastBtnNarrow.addEventListener('click', () => changeAutoPlaySpeed(10));

    memBtnNarrow.addEventListener('click', ()=>{
      toggleMemMode();
      memBtnNarrow.setAttribute('aria-pressed', memBtn.getAttribute('aria-pressed'));
    });
    autoPlayBtnNarrow.addEventListener('click', ()=>{
      toggleAutoPlay();
      autoPlayBtnNarrow.setAttribute('aria-pressed', autoPlayBtn.getAttribute('aria-pressed'));
    });
    resetMemBtnNarrow.addEventListener('click', resetMem);
    copyBtnNarrow.addEventListener('click', copyAll);
    fontDecBtnNarrow.addEventListener('click', ()=>{ changeFont(-1); });
    fontIncBtnNarrow.addEventListener('click', ()=>{ changeFont(1); });
    helpBtnNarrow.addEventListener('click', showHelp);
    musicBtnNarrow.addEventListener('click', toggleMusicPlayer);

    // Music sync event listeners
    musicSyncBtn.addEventListener('click', toggleMusicSync);
    musicSyncBtnNarrow.addEventListener('click', toggleMusicSync);
    musicSyncBtnPlayer.addEventListener('click', toggleMusicSync);

    // Sync speed selector
    syncSpeedSelect.addEventListener('change', (e) => {
      musicSyncSpeed = parseInt(e.target.value);
    });

    // Music selection dropdown
    musicSelect.addEventListener('change', (e) => {
      if (e.target.value === 'custom') {
        youtubeUrl.style.display = 'block';
        youtubeUrl.focus();
      } else if (e.target.value) {
        youtubeUrl.style.display = 'none';
        youtubeUrl.value = e.target.value;
        loadMusic();
      } else {
        youtubeUrl.style.display = 'none';
        youtubeUrl.value = '';
      }
    });

    window.addEventListener('load', ()=>{
      fontPreset.value = DEFAULT_FONT_SIZE;
      sheet.style.fontSize = DEFAULT_FONT_SIZE + 'px';

      loadContentFromMarkdown();

      // Initialize after content is fully loaded
      initializeAfterContentLoad();

      // Auto-load default music
      youtubeUrl.value = defaultMusicUrl;
      setTimeout(() => {
        loadMusic();
      }, 1000);
    });

    window.addEventListener('resize', ()=>{
      responsiveColumnAdjust();
      setTimeout(checkToolbarWrap, 100);
    });
  </script>
</body>
</html>
